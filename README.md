# Лабораторная работа №5. Многопоточный сервер

### Интересности
#### Пул потоков
Класс  `Server::Multithreading::ThreadPool` реализует пул потоков, позволяющий в удобном формате вычислять функции.
- ```ThreadPool(size_t _threads_count)``` – констуктор, создает _threads_count спящих потоков.
- `add_task(F&& task, Args&&... args)` – добавляет задачу в очередь на выполнение. Принимает на вход функцию, которую нужно выполнить и аргументы для нее. Возвращает объект `std::future<...>`,
где вместо `...` указан тип возвращаемого значения функции. Далее, когда результат будет готов, можно получить его вызовом метода `get()`.

#### Класс `Server::Server`
Класс `Server::Server` реализует многопоточный сервер, который слушает порт и обрабатывает запросы клиентов. В качестве аргумента конструктора принимает порт, на котором нужно слушать соединения, максимальное количество клиентов, ожидающих соединение и количество потоков в пуле потоков. Сколько будет потоков в пуле, столько клиентов сможет одновременно обрабатываться.

#### RAII-обертки для работы с сокетами
Классы `Server::ListenerSocket` и `Server::ClientSocket`, унаследованные от базового класса `Server::Socket` реализуют RAII-обертки для работы с сокетами. 
 - `Server::ListenerSocket` с помощью своего конструктора позволяет создать слушающий сокет, а с помощью метода `accept()` – принять соединение. Соединение возвращается в виде `std::shared_ptr<ClientSocket>`. 
Возвращается именно указатель, потому что все сокеты являются некопируемыми, и передача по значению невозможна. При этом, если возникнет необходимость написать lamda-функцию, работающую с таким сокетом, то функция будет move-only, и сохранить ее в std::function уже не выйдет. Это накладывает существенные ограничения, поэтому возвращается именно shared_ptr.
 - `Server::ClientSocket` позволяет читать и писать данные в сокет. У него нет публичного конструктора, поэтому создать его можно только через `Server::ListenerSocket::accept()`. Класс предоставляет методы для чтения байтов с сокета и записи их туда же. 
 - `Server::Socket` – базовый класс, содержащий общие методы для работы с сокетами. Также именно в его деструкторе происходит закрытие файлового дескриптора, отвечающего за сокет.

#### Кастомные эндпоинты и хендлеры
Для написания собственных хендлеров достаточно просто унаследоваться от класса-интерфейса `Server::Handlers::IHandler` и реализовать метод `handle()`. 
Метод `handle()` не принимает на вход ничего, и возвращает `Server::Response`. Внутри метода можно использовать методы `read_byte()`, `read_bytes()`, `write_byte()`, `write_bytes()` для чтения и записи данных в сокет. Также, для удобного возврата ответа клиенту есть несколько готовых функций, возвращающие стандартные ответы: `not_found_response(), ok_response(), bad_request_response()` и еще несколько других.

Также, необходимо реализовать конструктор, принимающий на вход `Server::ClientSocket` первым аргументом. Остальные аргументы могут быть любые, в зависимости от того, что требуется для работы хендлера.

Далее, когда хендлер реализован, его можно добавить в сервер, вызвав шаблонный метод `add_handler()`. В качестве параметра шаблона необходимо передать тип хендлера, например, `Server::Handlers::EchoHandler`. Первый аргумент конструктора хендлера – это байт, который будет определять эндпоинт. Следующими аргументами можно передать любые данные, необходимые для создания объекта хендера (кроме `Server::ClientSocket`, который передается автоматически).
На каждого пользователя создается свой объект хендлера, поэтому имеет смысл передавать некоторые объекты по ссылке -- например, общий для всех клиентов на этом эндпоинте пул потоков.

Например, вот так добавляется хендлер, который просто отвечает клиенту его же сообщением:
```cpp
server.set_endpoint<Server::Handlers::EchoHandler>('e');
```


