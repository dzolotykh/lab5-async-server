# Класс сервера
## Описание
Класс сервера предназначен для обработки запросов клиентов и отправки им ответов. Сервер работает по протоколу TCP. Вместо того, чтобы создавать на каждого клиента отдельный поток, сервер обрабатывает их с помощью пула потоков. При этом, сервер может обрабатывать запросы от нескольких клиентов одновременно.

## Со стороны клиента
Первым байтом клиент должен отправить байт, который будет интерпретироваться как эндпоинт. Если такого эндпоинта нет, сервер вернет ему ошибку. Если же эндпоинт есть, сервер вызовет конкретный обработчик, передаст в него объект `ClientSocket`, и обработчик будет обрабатывать сообщения от клиента.


## Интерфейс класса
- `Server(uint16_t port, int max_connections, int thread_pool_size)` – конструктор, создающий сервер, который будет принимать входящие соединения на порту `port` с максимальным количеством соединений `max_connections` и пулом потоков размера `thread_pool_size`.
- `void start()` – запускает сервер. Сервер начинает принимать входящие соединения и обрабатывать их. Эта функция блокирует выполнение программы, поэтому, если необходимо завершать сервер извне, то это нужно делать в другом потоке (или сделать обработчик для сигналов, а лучше и то, и другое).
- `void stop()` – останавливает сервер. Сервер перестает принимать входящие соединения и завершает работу. Этот метод дожидается завершения всех уже открытых соединений, и лишь затем завершает работу сервера.
- `~Server()` – деструктор, который закрывает все соединения и освобождает ресурсы.
- `template<typename handler_t, typename... handler_constructor_params_t> void set_endpoint(char endpoint_byte, handler_constructor_params_t&&... constructor_params)` – шаблонная функция установки обработчика на определенном эндпоинте (он задается первым байтом сообщения). Шаблонный параметр `handler_t` указывать необходимо, это должен быть объект, 
унаследованный от `Server::IHandler` (об этом интерфейсе позже). Первым аргументом конструктор `handler_t` должен принимать `const ClientSocket&`. Остальные аргументы могут быть любыми, и должны быть переданы в этот метод. Для каждого пользователя, выбравшего этот эндпоинт, будет создан новый объект `handler_t`, и он будет обрабатывать все сообщения от этого пользователя путем вызова метода `handle()`.

## Кастомные обработчики
Для того, чтобы создать кастомный обработчик, необходимо унаследоваться от класса `Server::IHandler` и реализовать метод `handle()`, возвращающий `Server::Response`. Чтобы метод знал, какого клиента он обрабатывает, также обязательно надо реализовать конструктор, принимающий на вход первым аргументом `const ClientSocket&`. `IHandler` – это абстрактный класс с полем для хранения сокета клиента, поэтому при наследовании от него в любом случае придется реализовать конструктор.

В методе `handle()` можно делать что угодно и как угодно, а после обработки запроса нужно вернуть объект `Server::Response`. Этот объект, по сути, просто обертка над `std::string`. Для формирования стандартный ответов есть соответствующие методы. Также, если отправить пустой запрос, то сервер просто не будет ничего писать клиенту (это может быть удобно при отправке клиенту файла).
